scope&&context
我们知道JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段, 这两个阶段所做的事并不一样：
解释阶段：
词法分析
语法分析
作用域规则确定

执行阶段：
创建执行上下文
执行函数代码
垃圾回收
JavaScript 中有三种执行上下文类型。

全局执行上下文 — 
这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），
并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
函数执行上下文 — 
每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有
任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
Eval 函数执行上下文 — 
执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。

每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部

JavaScript解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。
执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。

作用域和执行上下文之间最大的区别是：
执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。
 

在函数中如果变量没有加修饰符，那么他就是个全局变量，即类似于修改了全局的此变量，如果全局没有则会添加一个。函数里面就算是用var修饰，还是局部变量。

在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：
this 值的决定，即我们所熟知的 This 绑定。
创建词法环境组件。
创建变量环境组件。

this指向
this永远指向调用者
ps:箭头函数的this指向的都是此函数的父级的this，如果不是箭头函数一律指向window


closure
匿名函数本身就会形成一个闭包

模块化
require命令用于加载模块文件。require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错

ES6 模块与 CommonJS 模块的差异
它们有两个重大差异：
CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。


进入项目敲vue inspect可以看到webpack默认配置